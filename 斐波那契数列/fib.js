let memo = [];
function fib(n) {
  if (n === 0) {
    return 0;
  }
  if (n === 1) {
    return 1;
  }
  // 添加记忆数组
  if (memo[n] === undefined) {
    memo[n] = fib(n - 1) + fib(n - 2)
  }
  return memo[n]
}
// 这个算法的时间复杂度是指数级的，之所以时间复杂度这么高原因是
// 这是一个递归树，每计算一个节点的值，就要计算它下面的节点的值。
// 这样就会存在大量的重复计算, 优化的思想其实很简单，就是对于这些重复的数字
// 我们有没有办法只计算1次呢，这样的话就不会有这么多冗余的算法了。

// 虽然是同样使用递归，但是并不是每次计算都要调用递归算法，而是将n的值记录下来
// 下次再计算的时候，首先搜索数组中是否已经计算过了，计算过了就取这个存储的值，没有计算过
// 就调用递归逻辑，这种方法叫做记忆搜索。

let n = 40;
let res = fib(n);
console.log(res);

// 老师引出了一个概念：什么是自上而下的解决问题，什么是自下而上的解决问题, 这部分的概念需要细心琢磨。


